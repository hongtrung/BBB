		***BUỔI 1***
- cpu(não)
- hệ thống ngoại vi(tay chân)
- hệ thông bus(kinh mạch)
- clock(máu)



>>>>>>>>>ARM

-Application: 	+ Lập trình ứng dụng ngừoi dùng
		+ tốn năng lượng
		+ khả năng sử lý cao
-Realtime: 	+ ứng dụng có tính quan trọng về mặt thời gian thực
		+ Hard-realtime
		+ Soft-realtime
-Micontroller: 	+ Được sử dụng rộng rãi cho các hệ thống smarthome, iot...
		+ Tiết kiệm năng lượng



>>>>>>>>> Bộ BSP

- Bootloader:	Bộ nạp khởi động.(Tối ưu thời gian khởi động thêm cmd điều khiển, phân vùng lại flash,... )
- linux Kernel:	Quản lý phần mềm phần cứng
- Rootfs:	không gian chạy các ứng dụng
- Toolchain: 	Compiler, công cụ giúp phát triển các ứng dụng(có sẵn, học cách sử dụng)




>>>>>>>>> Mảng nhúng ở việt nam

- nhóm cty làm về outsource (Điển hình FPT) 
		(nhận dự án nước ngoài): nhận thiết bị bên brander, hợp tác làm ra 1 bộ BSP
	+ - Bootloader:	Bộ nạp khởi động.(Tối ưu thời gian khởi động thêm cmd điều khiển, phân vùng lại flash,... )
	+ Linux kernel: viết driver: I2C/SPI/USBT/CAN/GPIO,...
	+ Rootfs: Phát triển các ứng dụng trên tầng usr space

- nhóm cty làm về product (VNPT, FPT, Lumi, Dasan, Vinfast,...)
 	
 	VD: làm 1 con bóng đèn đáp ứng chức năng bluetooth, zigbee,...
 	
 	>>>>>HW
 	B1: tìm 1 thiết bị có sẵn trên thị trường đáp ứng được chức năng + chi phí mà bài toán đưa ra
 	B2: Design lại phần cứng, loại bỏ các thành phần không cần thiết.
 	
 	>>>>>SW
 	B1.0: Bringup, Porting hệ điều hành lên cái phần cứng đã designed.
 		- Tối ưu lại các thành phần phần mềm của hệ thống
 			+ u-boot
 			+ kernel
 			+ rootfs
 	B1.1: phát triển applications.	(TRỌNG TÂM)
 			+ Viết app





































-----------------------------------------------------------------------------------------------------












		***BUỔI 2***
* Makefile
- makefile là 1 script bên trong có chứa thông tin :
	+ cấu trúc của một project(file, dependency)
	+ các command line dùng để tạo hủy file.
- chương trình make sẽ đọc nội dung trong Makefile và thực thi nó.

- cấu trúc của 1 câu lệnh Makefile 
		Target: Dependences
  		Tab	Action
  	VD:
		all: hello.c main.c 
			gcc -o examble hello.c main.c -I .
			...
		clear:
			rm -rf examble
			
$@: là target
$<: giá trị đầu tiên bên phải dấu : (dependency đầu tiên)
$^: toàn bộ giá trị nằm bên phải dấu : (toàn bộ dependency)	
	
------Các phép gán giá trị.		
var := "var"
var1 = $(var) // là phép gán đệ quy: nhận giá trị gán cuối cùng
var2 := $(var) // phép gán trực tiếp: chỉ nhận 1 giá trị tại thời điểm gán
var3 ?= $(var) // thực hiện kiểm tra xem var3 có giá trị chưa, nếu có sẽ giữ nguyên giá trị của var3, nếu chưa thực hiện phép gán đệ quy.

biến .PHONY: rule1 rule2 rule3 ... (có tác dụng tránh lỗi file trùng tên với rule không chạy chương trình)

# để comment

quy tắc set tên makefile và độ ưu tiên: Makefile>makefile>abc.mk

để chạy abc.mk --> make -f abc.mk

1 makefile muốn include đến 1 makefile khác --> include abc.mk


kiểm tra các file sửa đổi	
	INC_FILE := hello.h
	CC := gcc
	CFFLAG := -I.
	
	%.o: %.c $(INC_FILE)
		$(CC) -I. -c -o $@ $<

-o là output 
-c là đưa ra 1 file object .o

(gcc -I -c -o main.o main.c)

>>>>>>>>>>>>>>Compiling a C program
1) gia đoạn tiền sử lý(pre-processing)
	- Loại bỏ comments
	- mở rộng các macros
	- mở rộng các include file
	- biên dịch các câu lệnh điều khiển
	- kết quả thu được sau bước này là 1 fiel.i
	gcc -E hello.c -o hello.i 
	
2) giai đoạn dịch ngôn ngữ bậc cao sang asm(compilation)
	- ở gia đoạn này, mã nguồn sẽ tiếp tục thực hiện biên dịch từ file.i thu được thành 1 file.s(assembly)
	gcc -S hello.i -o hello.s
	
3) giai đoạn dịch asm sang mã máy(Assembly)
	- File.s ở giai đoạn trước tiếp tục được sử dụng cho giai đoạn này
	- thông qua assembler, output mà chúng ta thu được 1 file.o. Đây là file chứa các chỉ lệnh cấp độ ngôn ngữ máy (machine language: nhị phân 01)
	gcc -c hello.s -o hello.o
	hexdump -c hello.o
	
4) Giai đoạn linked (linking)
	- Mỗi 1 file.o thu được ở giai đoạn Assembly là một phần của chương trình
	- ở giai đoạn linking sẽ liên kết chúng để thu được 1 file thực thi hoàn chỉnh.
	gcc -o hello hello_0.o hello_1.o hello_2...
	
	
>>>>>>STATIC LIB AND SHARE LIB
	thư viện là một tập hợp các đoạn mã được biên dịch sẵn để có thể được sử dụng lại trong 1 chương trình
	
	được chia làm 2 lại 
		- static_lib: thư viện đọc
		- share_lib: thư viện chia sẻ được

	có N Source_File --> có N Object_file --> Linker}
				Runtime_library--> Linker} --> executable program

properties		static_lib			shared_lib
linking time	|all module trong thư viện	|đc sử dụng trong quá trình link khi 
		|đc copy vào file thự thi	|mà cả file thự thi và file lib được load 
		|				|vào bộ nhớ
size		|tốn nhiều bộ nhớ hơn 		|tốn ít bộ nhớ hơn


external file	|phải recompile bất cứ lúc nào	|không cần biên dịch lại file thực thi
changes		|có sự thay đổi		|


time		|mất nhiều thời gian hơn	|tốn ít hơn



* Phân chia folder 1 project
	- Bin chứa examble
	- inc chứa file.h
	- lib chứa static_lib và shared_lib
	- obj chứa file.o
	- src chứa file.c
	- main.c để ngoài 
	
* tạo static_lib
bước 1: tạo các file.o
	
	gcc -c main.c -o obj/main.o -I./inc
	
	giải thích: 	
		- c: tạo ra file object từ main.c
	    	- o: tạo ra file output đặt trong thư mục obj và có tên là main.o
	    	- I./inc: chỉ định folder chứa các file.h hay include các file.h
Bước 2: Create static lib
	
	ar rcs lib/static_lib/libhello.a obj/hello.o obj/hi.o ....  
  	
  	giải thích: 
  		- ar rsc 
	    	- lib/static_lib/libhello.a nơi lưu file lib.a
	    	- obj/hello.o obj/hi.o ... là cái file.o muốn lib
Bước 3: Link statically

	gcc obj/main.o -Llib/static_lib -lhello -o bin/exam
	
	giải thích:
		- obj/main.o: liên kết file main.o với thư viện
		- -L lib/static_lib: cờ -L biểu thị thư mục nơi có thể tìm thấy các lib
		- -l hello: cờ -l cho biết tên của thư viện bỏ (lib và .o)
		- -o bin/exam: tạo ra file output đặt trong folder bin tên là exam

*tạo shared_lib
bước 1: tạo các file.o tương tự static_lib
bước 2: create shared lib
	
	gcc -shared obj/hello.o obj/hi.o -o lib/shared_lib/libhi.so
	
	giải thích:
		- -shared: tạo lib share
		- obj/hello.o obj/hi.o... các file.o cần tạo thư viện
		- lib/shared_lib/libhi.so tạo file.so tại địa chỉ kia 
bước 3: link dynamically with the shared lib(tạo liên kết động với thư viện shared)
	
	gcc obj/main.o -L lib/shared_lib -l hi -o bin/examble



































---------------------------------------------------------------------------------------


		***BUỔI 3***
I. TÔNG QUAN VỀ FILE TRÊN LINUX.
	Linux quản lý tất cả mọi thứ như 1 file
		- regular file: là các file thông thường như text file executalbel file
		- directories file: file chứa danh sách các file khác
		- character device file: file đại diện cho các thiết bị không có địa chỉ vùng nhớ
		- block device file: file đại diện cho các thiết bị có địa chỉ vùng nhớ 
		- link file: file đại diện cho 1 file khác
		- socket file: file đại diện cho 1 socket
		- pipe file: file đại diện cho 1 pipe
	lệnh ls -l lấy ra toàn bộ thông tin file
	     ls -lh
	lệnh sudo su để truy nhập quyền user root
	
		số hardlink file là số file cùng trỏ đến 1 vùng nhớ trên ổ cứng
		- loại file : "-" regular file
				"d" directories
				
user permission		group permission	other permission
r-w-x 1-1-1  7		r-w-x  1-1-1		r-w-x  1-1-1			
r-w   1-1-0  6

để loại bỏ quyền r-w-x của file sử dụng câu lệnh:
	chmod u-r <tên file> loại bỏ quyền r trong user permission
	chmod g-r <tên file> loại bỏ quyền r trong group permission
	chmod o-r <tên file> loại bỏ quyền r trong other permission
để add quyền cho file sử dụng lệnh:
	chmod u+r <tên file> add quyền r trong user permission
	chmod g+r <tên file> add quyền r trong group permission
	chmod o+r <tên file> add quyền r trong other permission
thêm quyền rw cho cả user group other sử dụng lệnh
	chmod 0666 <tên file>
full quyền 
	chmod 0777 <tên file>
chuyển quyền sở hữu file cấp user:
	sudo chown trungdoan <têb file>
chuyển quyền sở hữu file cấp user&group:
	sudo chown trungdoan:trungdoan <tên file>
	
chmod: change quyền
chown: change user group
	
II. ĐỌC GHI FILE TRÊN LINUX
* kernel cung cấp 1 bộ system call cơ bản để thực hiện việc đọc ghi và thao tác với các file bao gồm:
	- open()  
		int open(const char* pathname, int flags, mode_t mode);
	vd:
		int fd;
		fd = open("hello.txt", O_RDONLY, 0666); 
	
		+ const char* pathname: đường dẫn tới file "hello.txt"
	
		+ int flags: O_RDONLY chỉ đọc, O_WRONLY chỉ ghi, O_RDWR vừa đọc vừa ghi, O_CREAT kiểu tra xem có file chưa, chưa có thì tạo file....
	
		+ mode_t mode: r-w-x :0666
		
	- read()
		ssize_t read(int fd, void* buffer, size_t count);
	vd:
	
	- write()
		ssize_t write(int fd, void* buffer, size_t count);
	vd:
		int numb_write;
		char buf1[12] = "hello world\n";
		numb_write = write(fd, buf1, strlen(buf1));
		
	- lseek()
		off_t lseek(int fd, off_t offset, int whence);
	vd: 	lseek(fd, 2, SEEK_SET);
	SEEK_SET: con trỏ file ở đầu file
	SEEK_CUR: con trỏ file ở vị trí hiện tại 
	SEEK_END: con trỏ file ở cuối file
		
	- close()
		int close(int fd);
	vd 	close (fd);

fd: file descriptor(định danh của file)

III. Quản lý file trong Linux
* kernel điều khiển việc tương tác giữa các tiến trình thông qua 3 bảng

- file descriptor table: 

- open file table: chứa các inode ptr, status flag, file offset(SEEK_SET+0,SEET_SET +1,...)

- i-node table: mỗi phần tử trong bảng i-node đại diện cho 1 file chứa các thông tin của file như: inode number, file type, size, hardlink, permission, file ptr

	Thực hiện đọc ghi thì từ file descriptor->open file -> i node file

* trong cùng 1 process có thể có nhiều FDs cùng tham chiếu vào 1 vị trí trong OFD
 sử dụng dup(), dup2().
* hai process mở cùng 1 file tham chiếu tới cùng 1 OFD
sử dụng fork()
* 2 process cùng mở 1 file tham chiếu tới cùng 1 inode
* khi tiến trình dùng lệnh read()/write()

READ()
1. kernel xác định page cần đọc
2. kernel đọc từ page cache
3. nếu page có trong page cache thông tin sẽ được đọc ra
4. Nếu page không có trong page cache, Đọc từ cùng nhớ vật lý vào page cache sau đó đọc ra cho userspace

WRITE()
1. kernel ghi nội dung page vào page cache
2. page cache sẽ được ghi vào vùng nhớ vật lý định kỳ hoặc khi dùng các lệnh sync(), fsync().

IV. File locking
- record lock
- file lock

-file locking dùng để quản lý việc nhiều tiến trình cùng đọc/ghi vào 1 file
- cách hoạt động:
bước 1: ghi trạng thái vào i node của file
bước 2: nếu thành công thì thực hiện đọc ghi file, nếu không thânhf công nghĩa là file đang đc tiến trình khác sử dụng
bước 3: sau khi đọc/ghi xong gỡ trạng thái lock ra khỏi i node của file

Flock() đơn giản, thông tin ghi vào inode là trạng thái lock, lock toàn bộ file. tại 1 thời điểm chỉ có 1 tiến trình đọc/ghi file

Fcntl()	phức tạp, thông tin ghi vào inode là trạng thái lock, khu vực lock, tiến trình lock, lock được từng khu vực của file, nhiều tiến trình có thể đọc/ghi cùng 1 file mà không bị xung đột					

-lock file với flock()
	int flock(int fd, int operation);
	Flock dựa vào thông tin file descirptor để đặt trạng thái lock vào inode table
	
	các đối số:
	fd: file descriptor của file cần lock
	operation: giá trị lock muốn set
	- LOCK_SH: nếu set giá trị này thành công tiến trình có thể đọc file, không ghi
	- LOCK_EX: nếu set giá trị này thành công tiến trình có thể đọc ghi file 
	- LOCK_UN: set giá trị này để báo rằng file không bị lock
	- LOCK_NB: nếu không dùng flag này hàm flock sẽ không kết thúc cho tới khi set được lock.
	
	TIến trình A			Tiến trình B
	lock_sh			có thể set lock_sh, không thể set lock_ex
	lock_ex			không thể set lock_sh, lock_ex
	

- lock file với fcntl()
	fcntl(fd, cmd, &flockstr)
	fcntl linh hoạt hơn flock. fcntl cho phép lock từng phần của file(thậm chí đến từng byte). thông tin lock đặt vào inode table sẽ gồm process ID, trạng thái lock, vùng lock
	
	các đối số:
	. fd: file descriptor của file cần lock
	. cmd: action muốn thực hiện
		. F_SETLK: đặt lock, bỏ lock
		. F_GETLK: đọc thông tin lock
	. flockstr: thông tin muốn lock(gồm trạng thái lock, vùng muốn lock, process lock)
	 
	 struct flock
	 {
		short l_type;	//lock type: F_RDLCK, F_WRLCK, F_UNLCK
		short l_whence;	// how ti interpret 'I_start': SEEK_SET, SEEK_CUR, SEEK_END
		
		off_t l_start;	// offset where the lock begins
	 	off_t l_len;	// number of byte to lock, 0 means "until EOF"
	 	pid_t l_pid;	// process preventing our lock(F_GETLK only)
	 }	
struct flock fl{
	fl.l_start = 1;                         // offset vi tri lock dau tien
        fl.l_len = 5;                           // number of bytes to lock, 0 means lock "until EOF" 
        fl.l_type = F_WRLCK;                    // lock type: F_RDLCK, F_WRLCK, F_UNLCK
        fl.l_whence = SEEK_SET;                 // how to interpret: SEEK_SET, SEEK_CUR, SEEK_END
}






























------------------------------------------------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>BUỔI 4 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Giới thiệu 
* chương trình (program) và tiến trình (process) là 2 thuật ngữ có liên quan tới nhau
* cần phải phân biệt giữa tiến trình và chương trình
* mỗi 1 process có 1 mã vùng dùng để định danh gọi là process id (PID), đây là một số nguyên dương và duy nhất cho mỗi process trên hệ thống.
* Program là một nhóm các câu lệnh thực thi nhiệm vụ cụ thể, được cụ thể bằng các file thực thi và nằm trên ổ cứng máy tính
* process là 1 chương trình đang được thực thi và sử dụng tài nguyên của hệ thống

* sử dụng lệnh top để kiểm tra các process đang chạy trong hệ thống
* lệnh ps, ps a, ps aux | grep <tên tiến trình> để xem PID
 
 file descriptor # PID
định danh của file duy nhất trong process
định danh của process duy nhất trong toàn bộ hệ thống


I) Command-line Arguments
* mỗi một chương trình đều bắt đầu khởi chạy từ hàm main().
* Khi chạy chương trình, các tham số môi trường (command-line arguments) sẽ được truyền qua hai đối số trong hàm main().
	+ argc: số lượng tham số truyền vào hàm main()
	+ argv(): mảng con trỏ, trỏ tới các tham số được truyền cho chương trình đó.


----------------------------------------------------------------------------
****MEMORY LAYOUT của 1 process****

		kernel
	0xC0000000	
		->argv, environ 
		-> stack(grows downwards)
	top of stack
		-> (unallocated memory)
	program break
từ đây xuống dưới là vùng	increasing virtual addesses 
		-> Heap(grows upwards)
		-> Uninitialized data(bss) 
		-> initialized data
		-> text segments (program code)
		-> 0x08048000
		   0x00000000
* bộ nhớ cấp phát cho mỗi 1 process được chia thành nhiều phần khác nhau. Thông thường chúng sẽ được gọi là các segments (các phân đoạn vùng nhớ).

	- Text segments(vùng nhớ văn bản): chứa các chỉ lệnh ngôn ngữ máy(machine-language) của program. vd: printf(".........");
		Segment này có quyền read-only
		
	- Initialized data segment(vùng nhớ được khởi tại): bao gồm các biến global và biến static đã được khởi tạo 1 cách tường minh.
		Segment này có quyền read, write
		vd: int a = 5;(biến global tường minh)
		    static int a = 5;
	- Uninitialized data segment(bss): bao gồm các biến global và biến static không được khởi tạo tường minh.
		Segment này có quyền read, write.
		vd: int a;
		    static int a;

	- Stack segment: có thể co dãn vùng nhớ bằng cách cấp phát hoặc giải phóng các stack frames.
		Segment này có quyền read, write
	- Heap segment: dành cho việc cấp phát bộ nhớ một cách tự động. Sử dụng các hàm như alloc(), malloc(), calloc(). Heap có thể co dãn tương tự như stack. Điểm kết thúc của Heap được gọi là program break. Segment này có quyền read, write.

stack frame của các hàm main() trong chương trình.
khi gọi đến 1 hàm khác trong chương trình, thì sẽ lưu trữ con trỏ vị trí hàm main vừa kết thúc, và lưu trữ các biến local của hàm vừa gọi, để sau khi thực hiện xong sẽ dọn dẹp luôn stack frame của hàm vừa gọi (loại bỏ luôn), trỏ lại đến vị trí hàm main vừa kết thúc.(lưu trữ vị trí con trỏ ở đâu)

----------------------------------------------------------------------
****THAO TÁC VỚI PROCESS****
1. Tạo 1 tiến trình mới.
	- sử dụng system call fork().
	- tiến trình gọi fork() được gọi là tiến trình cha mẹ(parent process)
	- tiến trình mới được tạo ra gọi là tiến trình con (child process)
	- tiến trình init là tiến trình đầu tiên được chạy, là cha của mọi tiến trình khác và có pid là 1
	
	kiểu dữ liệu: pid_t : dữ liệu là kiểu số nguyên có dấu có khả năng biểu diễn ID tiến trình
	getpid(void): trả về pid của tiến trình hiện tại
	getppid(void): trả về pid của tiến trình cha tiến trình hiện tại.
	
2. chạy 1 chương trình mới
	- trong nhiều trường hợp bạn đang có 1 tiến trình A đang thực thi và bạn muốn chạy 1 chương trình B nào đó từ tiến trình A hoặc con của nó. Điều này hoàn toàn có thể thực hiện được thông qua việc sử dụng 1 danh sách các hàm thuộc dòng exec.
	
	- int execle(const char* pathname, const char* arg,...);
	- int execlp(const char* filename, const char* arg,...);
	- int execvp(const char* filename, const char* arg[]);
	- int execv(const char* pathname, const char* arg[]);
	- int execl(const char* pathname, const char* arg,...);

3. Kết thúc tiến trình
	- Kết thúc bình thường (normally termination)
		+ Một process có thể hoàn thành việc thực thi của nó một cách bình thường bằng cách gọi system call _exit() hoặc dùng hàm exit()
		+ _exit(): void _exit(int status);
		+ exit(): void exit(int status);
	- Kết thúc bất thường (abnormally termination)
		+ một process có thể bị kết thúc bằng cách sử dụng lệnh kill trong linux: kill -9 <PID>
		+kill -l: hiển thị sig
	
------------------------------------------------------------------------------
>>>>>>>>>>>>>>>>PROCESS MANAGEMENT<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1. bài toán quản lý tiến trình
2. System call wait() và waitpid()
3. Tiến trình Orphane(mồ côi) và Zombie(xác sống)
4. Ngăn ngừa tiến trình Zombie
	
	
I. Bài toán quản lý tiến trình.
* một trong các triết lý về lập trình đó là "do one thing and do it well", làm một việc và làm tốt điều đó.
* Quản lý tiến trình về cơ bản được thực hiện bởi một vài system call, mỗi lệnh có mục đích (đơn giản). các lệnh này sau đó có thể được kết hợp để thực hiện các hành vi phức tạp hơn.

II. System call wait()
* System call wait() được sử dụng theo dõi trạng thái kết thúc của một trong các tiến trình con mà tiến trình cha tạo ra
	#include<sys/wait.h>
	
	pid_t wait(int* status);
	
parent process A --> B, C, D
gọi wait(); chờ đợi cho đến khi B, C, D kết thúc thì mới trả về status
retval = wait(&status)
return 0; bản chất là exit(0)

CÁCH THỨC HOẠT ĐỘNG CỦA WAIT()
* Tại thời điểm wait() được gọi, nó sẽ block cho đến khi có 1 tiến trình con kết thúc hoặc thay đổi trạng thái. Nếu tồn tại 1 tiến trình con đã kết thúc trước thời điểm gọi wait(), nó sẽ return ngay lập tức.
* Nếu status khác -1, status sẽ trỏ tới 1 giá trị là 1 số nguyên, giá trị này là thông tin về trạng thái kết thúc tiến trình.
* Khi wait() kết thúc, nó sẽ trả về giá trị PID của tiến trình con hoặc -1 nếu lỗi.
		- Trạng thái của 1 tiến trình
			+ S: Sleeping
			+ R: Running
			+ W: waiting
			+ T: suspended
			+ Z: zombie (defunct)
* System call wait() tồn tại một số hạn chế:
	- nếu tiến trình cha tạo ra nhiều tiến trình con(mutliple children), nó không thể dùng wait() để theo dõi một tiến trình con cụ thể. 
	- waitpid() được sinh ra để giải quyết vấn đề này.
	
	@param[in] pid 	pid > 0, PID của tiến trình con cụ thể mà wait muốn theo dõi.		
			pid = 0, ít sử dụng
			pid <-1, ít sử dụng
			pid ==-1, chờ bất cứ tiến trình con nào phụ thuộc về tiến trình cha - giống wait()
	
	@param[out] status 	trạng thái kết thúc của tiến trình con
	@param[in] options	Thông thường chúng ta sẽ sử dụng NULL ở trường này
	
	@return		trả về PID của tiến trình con nếu thành công, -1 nếu lỗi
	
	pid_t waitpid(pid_t pid, int* status, int options);	

III. Tiến trình Orphane và Zombie
* vòng đời của các tiến trình cha con thường không giống nhau. Tiến trình cha sống lâu hơn tiến trình con và ngược lại.
		2 câu hỏi được đặt ra:
			Nếu tiến trình cha kết thúc trước tiến trình còn, vậy tiến trình con rơi vào trạng thái orphane(mồ côi), vậy ai sẽ là cha mới của nó?
			Điều gì sẽ xảy ra nếu tiến trình con kết thúc trước khi tiến trình cha kịp gọi wait()?
			

*Tiến trình Orphane- Mồ côi.
	** nếu tiến trình cha kết thúc trong khi 1 hoặc nhiều tiến trình con của nó vẫn đang chạy, khi đó các tiến trình con đó sẽ trở thành các tiến trình mồ côi (orphane). 
	** tiến trình mồ côi sẽ được chấp nhận bởi tiến trình init có PID(1), và tiến trình init sẽ hoàn thành công việc thu thập trạng thái cho chúng.

*Tiến trình Zombie
	** Nếu tiến trình con kết thúc trước tiến trình cha được tạo ra, nó không hoàn toàn được giải phóng khỏi hệ thống mà rơi vào trạng thái Zombie.
	** Lúc này tài nguyên dành cho tiến trình được giải phóng, và chỉ giữ lại một số thông tin cơ bản như PID, trạng thai kết thúc tiến trình.
	** tiến trình bị xóa khỏi hệ thống khi tiến trình cha gọi wait() hoặc waitpid().
	
* Ngăn ngừa tiến trình Zombie
	** có 1 bảng process ID (PID) cho mỗi hệ thông, Kích thước của bảng này là hữu hạn.
	** nếu quá nhiều tiến trình zombie được tạo, thì bảng này sẽ đầy. Tức là hệ thống sẽ không thể tạo ra bất kì tiến trình mới nào, khi đó hệ thống sẽ đi đến trạng thái ngưng hoạt động.
	Có 2 cách xử lý:
		- luôn hiện gọi wait() ở tiến trình cha
		- khi tiến trình con kết thúc, một tín hiệu SIGCHLD sẽ được gửi tới tiến trình cha của nó 












































---------------------------------------------------------------------------------------------
	buổi 5 thread
	* giới thiệu
	* nguyên lý hoạt động
	* so sánh Process với Thread
	* thao tác với Thread


1, Nguyên lý hoạt động
	Tương tự process, thread được tạo ra với mục đích xử lý đồng thời nhiều công việc cùng lúc (mutil-task)
	* process: là 1 chương trình đang được thực thi và sử dụng tài nguyên của hệ thống.
	* Thread: là 1 lightweight process có thế được quản lý độc lập bởi một bộ lập lịch
	

	- trên một hệ thông mutil core. nhiều threads có thể đơcj hoạt động song song.
	- nếu 1 thread bị block, các thread khác vẫn hoạt động bình thường
	- mỗi khi 1 thread được tạo, chúng sẽ được đặt trong stack segments.
	
2, context switching( chuyển đổi ngữ cảnh)

	5 trạng thái: Ready, Running, Blocked, Blocked Suspended, Ready Suspended
	Khi 1 Thread mới được tạo ra: nó ở trạng thái Ready
	
	- So sánh Process với Thread:
* Context switching time: - process cần nhiều thời gian hơn vì chúng nặng hơn
			- Thread cần ít thời gian hơn vì chúng nhẹ hơn process.
	+ cùng phân tích lại bài toán: Một Network server được thiết kế để nhận và xử message đến từ nhiều clients khác nhau. Điều này có thể thực hiện bằng việc gọi Fork() tạo ra nhiều process để xử lý dữ liệu cho nhiều clients.
	+ ta cũng có thể xử lý bài toán trên với việc sử dụng mutil-Thread
	

* Shared Memory: - Chia sẻ dữ liệu giữa các tiến trình khó khăn hơn, Giao tiếp thông qua cơ chế IPC
		- các thread trong 1 process có thể chia sẻ dữ liệu với nhau nhanh chóng, dễ dàng
	+ khi tạo tiến trình với fork(), tiến trình và tiến trình con nằm trên 2 vùng nhớ được phân bố khác nhau. Dẫn tới việc chia sẻ dữ liệu giữa chúng trở nên khó khăn hơn
	+ Dữ liệu được chia sẻ giữa các Thread trong một tiến trình nhanh và dễ dàng hơn vì chúng nằm trong 1 không gian bộ nhớ của tiến trình


* Crashed: - Nếu 1 process bị crashed, process khác vẫn hoạt động bình thường.
	   - Nếu 1 thread bị crashed, các thread khác chấm dứt ngay lập tức.
	+ Khi tạo tiến trình với fork(), tiến trình và tiến trình con nằm trên 2 vùng nhớ được phân bố khác nhau, hoạt động độc lập với nhau. Khi 1 tiến trình xảy ra lỗi, tiến trình khác vẫn hoạt động bình thường.
	+ Các Thread trên 1 tiến trình hoạt động đồng thời với nhau. Khi 1 thread bị crashed sẽ khiến cho các thread khác chấm dứt
	
Các process có mối quan hệ đặc biệt(cha-con), thread thì ngang hàng với nhau.

* THREAD ID.
	- cũng như 1 process được xđ bởi PID, 1 thread trong process được xđ bởi 1 thread ID.
	- 1 số điểm phải làm rõ:
		+ PID là duy nhất trên toàn Hệ thống, trong đó Thread ID là duy nhất trong 1 process.
		+ PID là 1 gtrị số nguyên, nhưng thread id không nhất thiết phải là 1 giá trị số nguyên, nó có thể là 1 structure(thường sử dụng).
		+ PID có thể được in ra dễ dàng nhưng Thread ID thì không.
		
	- Thread ID sẽ được đại diện bởi kiểu pthread_t
	- phần lớn các trường hợp Thread ID sẽ là 1 structure nên để so sánh 2 thread ID với nhau ta cần 1 function có thể thực hiện việc này (đối với PID là một số nguyên, thì việc so sánh đơn giản hơn)
	- để làm được việc này ta sử dụng 2 hàm sau:
		+ pthread_self(); <==> getpid();
		+ pthread_equal();
		#include<pthread.h> 
		 int pthread_equal(pthread_t tid1, pthread_t tid2 )
	trả về 0 nếu 2 thread khác nhau, trả về # 0 nếu 2 thread bằng nhau
		 
		 pthread_t pthread_self(void);
	trả về thread id của thread đang gọi pthread_self	
 ứng dụng:
 	có 1 ds liên kết: bên trong chứa 2 trường: thread_id_1, data
 	từ 1 thread_id_x có thể lấy dữ liệu tương ứng với x, trong danh sách liên kết
 	- sd pthread_self lấy ra thread_id_x.
 	- sử dụng vòng lặp, sử dụng thread_equal(), truyền vào các thread_id tương ứng, nếu thread_id nào trùng với thread_id_x thì lấy ra ds tương ứng.
 	
 	
* thao tác với Thread.
1. tạo 1 thread mới.
	- chương trình (program) được khởi chạy và trở thành 1 tiến trình(process), lúc này bản thân tiến trình đó là 1 sigle-thread(tiến trình đơn luồng).
	- tiến trình tạo nhiều hơn 1 threads đc gọi là multiple-thread(tiến trình đa luồng)
	- ta có thể kết luận rằng mọi tiến trình đều có ít nhất 1 thread. trong đó, thread chứa hàm main được gọi là main thread.
	- để tạo 1 thread mới chúng ta sử dụng hàm pthread_create()
	
	int pthread_creat(pthread_t* threadID, const pthread_attr_t* attr, void*(*start)(void*), void* arg);
	+ đối số đầu tiên: một khi tiến trình được gọi thành công, đối số  đầu tiên sẽ giữ thread ID của thread mới được tạo này.
	+ đối số thứ 2: thông thường giá trị này đặt là NULL
	+ đối số thứ 3: là một con trỏ hàm(function pointer). Mỗi một thread chạy riêng một function, địa chỉ function này sẽ được truyền tại đối số thứ 3 để linux biết đc thread này bắt đầu chạy từ đâu
	+ đối số thứ 4: đối số arg được truyền vào có kiểu void. điều này cho phép ta truyền bất kỳ dữ liệu nào vào hàm xử lý của thread. Hoặc giá trị này có thể là NULL nếu ta không muốn truyền bất kỳ đối số nào. 

2. kết thúc với thread
* kế thúc với thread sử dụng hàm pthread_exit();

	void pthread_exit(void* retval);
retval là giá trị trả về khi kết thúc thread.
 + ta thấy hàm này chỉ chấp nhận 1 đối số, đó là giá trị trả về từ thread đang gọi hàm này.
 + gtrị trả về này được truy cập bởi thread cha đang đợi thread này kết thúc và có thể được truy cập bởi 1 thread khác thông qua pthread_join();
 


>>>>>>>>>>>>>>>>>>>>THREAD MANAGEMENT <<<<<<<<<<<<<<<<<<<<<<<<<<<

1. QUẢN LÝ THREAD

1.1 thread termination
	. thread kết thúc 1 cách bth
	. thread kthúc khi gọi hàm pthread_exit();
	. thread bị cancel khi gọi hàm pthread_cancel();
	. bất cứ 1 thread nào gọi hàm exit() or main thread kthúc thì all thread còn lại kthúc ngay lập tức.
	
	
	int pthread_exit(void* retval);
	1 thread có thể đc kthúc = cách gọi pthread_exit().
	các đối số: 
		- *retval chỉ định gtrị của thread, gtrị này có thể thu đc bởi 1 thread # thông qua pthread_join().
	 	- trả về 0 nếu thành công, < 0 nếu thất bại 
	 	
	 int pthread_cancel(pthread_t thread);
	 pthread_cancel() gửi 1 ycầu kthúc thread tới 1 thread cụ thể
	 các đối số:
	 	- thread: threadID của 1 thread cụ thể
	 	- trả về 0 nếu thành công, < 0 nếu thất bại
	 	
1.2 Joinable thread 
	. để thu đc gtrị kthúc của 1 thread # ta sử dụng pthread_join().
	. hoạt động này được gọi là joining
	
	int pthread_join (pthread_t thread, void** retval);
	các đối số
		. thread: threadID của 1 thread cụ thể.
		. **retval: nếu retval khác NULL, nó sẽ nhận đc giá trị trả về của pthread_exit().
		. trả về 0 nếu thành công, < 0 nếu thất bại

cách thức hoạt động:
	- pthread_join() sẽ block cho đến khi 1 thread kthúc(threadID được truyền vào đối số thread), nếu thread đó đã kthúc thì pthread_join return ngay lập tức.
	- khi thread kthúc, về cơ bản nó sẽ đc xử lý tương tự như 1 zombie process, nếu sl zombie thread ngày càng lớn. 1 lúc nào đó ta ko thể tọa thêm thread được nữa. vai trò của pthread_join tương tự waitpid();
	Điểm khác biệt giữa pthread_join() và waitpid()
	pthread_join() chỉ bắt được pthreadID mà được cung cấp
	waipid(0) có thể bắt được tất cả các trạng thái kthúc của tất cả các process.
	
1.3. Detaching a thread (không quan tâm)
- mặc định, 1 thread là joinable, tức là khi thread kthúc thì 1 thread khác có thể thu được giá trị trả về của thread đó thông qua pthread_join().
- tuy nhiên, nhiều trường hợp chúng ta ko cần quan tâm về trạng thái kthúc của thread mà chỉ cần hệ thống tự động clean và remove thread 1 cách tự động.
- trường hợp này chúng ta có thể đặt thread vào trạng thái detached thông qua việc gọi pthread_detached(). 
	
	int pthread_detached(pthread_t thread);
- 1 khi thread bị detached, ta không thể dùng pthread_join() để thu trạng thái kthúc của thread và thread ko thể trở về trạng thái joinable.
	Các đối số:
		- thread: Thread ID của 1 thread cụ thể
		- trả về 0 nếu thành công, < 0 nếu thất bại
		
1.4. Thread Synchronization (đồng bộ hóa)
1.4.1 Synchronization
	. 1 trong các điểm mạnh của thread đó chính là việc chia sẻ dữ liệu với nhau thông qua các biến global
	. tuy nhiên, nó sẽ tồn tại 1 số vấn đề đồng bộ
	. điều gì sẽ xảy ra nếu nhiều thread cùng sửa 1 biến vào cùng 1 thời điểm? hay 1 thread đang cố đọc gtrị của 1 biến trong khi thread khác đang sửa đổi biến đó?

1.4.2 Atomic/Noatomic
	
	Atomic: tại 1 thời điểm chỉ có 1 thread duy nhất được truy cập vào tài nguyên đươc chia sẻ(shared resource). vì vậy atomic là an toàn.
	
	Noatomic: nhiều threads có thể truy cập vào shared resource cùng 1 thời điểm. vì vậy noatomic là không an toàn.
	
1.4.3 Critical Section
	
	thuật ngữ critical section được dùng để chỉ đoạn code truy cập vào vùng tài nguyên đc shared resource giữa các threads và việc thực thi nó nằm trong bối cảnh atomic. tức là thời điểm đoạn code đc thực thi sẽ không bị gián đoạn bởi bất cứ 1 thread nào truy cập đồng thời vào shared resource đó.
	
1.4.4 Mutex
	
	Mutex (mutual exclusion) là 1 kỹ thuật đc sử dụng để đảm bảo rằng tại 1 thời điểm chỉ có 1 thread mới có quyền truy cập vào Shared resource.
	
	Việc triển khai mutex nhìn chung thực hiên qua 3 bước:
		- khởi tại khóa Mutex
		- thực hiện khóa mutex cho các shared resource trước khi vào critical section
		- thực hiện truy cập vào shared resource.
		- mở khóa/giải phóng khóa mutex.
		
	* Allocated Mutexes
		- khóa mutex là 1 biến kiểu pthread_mutex_t. trc khi sdụng thì ta luôn phải khởi tạo khóa mutex.
		- khóa mutex có thể đc cấp phát tĩnh or động
		     + pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
		     + int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr);
		- khi ko sdụng ta phải hủy mutex bằng:
			pthread_mutex_destroy(). (khởi tạo tĩnh thì không cần sử dụng hàm này )
		
	* Locking and unlocking a mutex
		- sau khi khởi tạo, khóa mutex rơi vào trạng thái unlocked.
		- để lock or unlock 1 khóa mutex ta sdụng 2 hàm pthread_mutex_lock() và pthread_mutex_unlock().
		
	* int pthread_mutex_lock(pthread_mutex_t* mutex);
	
	khi khóa mutex ở trạng thái unlocked, pthread_mutex_lock() sẽ return ngay lập tức. ngược lại, nếu mutex đang locked bởi 1 thread khác thì pthread_mutex_lock() sẽ bị block cho tới khi mutex đc unlock
	- các đối số:
		+ *mutex: con trỏ tới khóa mutex
		+ trả về 0 nếu thành công, < 0 nếu thất bại
		
	* int pthread_mutex_unlock(pthread_mutex_t* mutex);
	
	Unlock 1 khóa mutex.
	- các đối số:
		+ *mutex: con trỏ tới khóa mutex
		+ trả về 0 nếu thành công, < 0 nếu thất bại
		
1.4.6 Mutex deadlocks
	- hiện tượng 1 thread khóa 1 mutex và không thể thoát được, gọi là mutex deadlocks
	
1.4.7 condition variables(biến điều kiện)

	- 1 mutex đc sdụng việc truy cập vào shared variable cùng 1 thời điểm
	- 1 condition variable đc sdụng để thông báo tới 1 thread khác về sự thay đổi của 1 shared variable và cho phép 1 thread khác block cho tới khi nhận được thông báo.

* ALLOCATED CONDITION VARIABLES 
	- condition variables là 1 biến kiểu pthread_cond_t.
	trc khi sd thì ta luôn phải khởi tạo nó.
	- condition variables có thể đc cấp phát động or tĩnh
	   + pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
	   + int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr);
	   
	- khi ko sd ta phải hủy condition variables bằng: pthread_cond_destroy(). (khởi tạo tĩnh thì không cần)
	
* SIGNALING/WAITING TRÊN condition variables
	- 2 hđ chính của condition variables là signal và wait
		+ pthread_cond_signal(&cond);
		+ pthread_cond_wait(&cond, &lock);
		
--------------------------------------------------------------------------------------
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
----------------------------------------------------------------------------
>>>>>>>>>>>>> BUỔI 6: SIGNAL <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1. Giới thiệu
2. Signal handler
3. 1 số signals cơ bản
4. Sending signal
5. blocking & unblocking signals



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
1. Giới thiệu.

- định nghĩa: Signal là 1 trong những phương thức dùng để giao tiếp liên tiến trình lâu đời nhất của Unix System.
- signal là 1 software interrupt, là cơ chế xử lý các sự kiện bất đồng bộ (async)
	VD:
	   + những sk này có thể bắt nguồn từ bên ngoài như khi người dùng nhấn tổ hợp phím Ctrl + C.
	   + or các hoạt động trong chương trình như phép chia 1 số cho 0.
	   
	- kill -l để xem toàn bộ lệnh signal.
	
1.1 Signal lifecycle
	* generation: đầu tiên 1 tín hiệu signal đc raised/sent/generated
	* delivery: 1 signal đc pending cho tới khi nó đc phân phối.
	* processing: 1 khi tín hiệu đc phân phối, nó có thể đc xử lý bởi nhiều cách.
		+ ignore the signal (phớt lờ tín hiệu)
			. ko action nào đc thực hiện
			. SIGKILL và SIGSTOP không thể bị ignore
		+ catch and handle the signal
			. kernel sẽ tạm dừng thực thi main thread và nhảy tới hàm xử lý signal đc user đk trong process(signal handler)
			. SIGINT và SIGTERM là 2 signal thường đc dùng
			. SIGKILL và SIGSTOP không thể catch
		+ perform the default action
			. Hành động này phụ thuộc vào từng loại signal.
		 
1.2 Signal handler

	sighandler_t signal(int signo, sighandler_t handler);
	 
	các đối số:
		+ signo: signal number
		handler: signal handler
	- Chúng ta đk việc xử lý 1 signal thông qua system call signal()
	- signal là 1 software interrupt nên nó khá nhạy cảm về mặt thời gian thực thi. Khi signal handler đc thực thi nó sẽ chiếmm hoàn toàn cpu của process.
	- cần phải thoát ra hàm xử lý signal nhanh nhất có thể 
	
	
1.3 Một số SIGNAL cơ bản
	- SIGKILL: chỉ có thể gửi bằng system call kill(). process ko thể caught or ignored. mặc định sẽ kthúc tiến trình đc chỉ định
	- SIGTERM:  chỉ có thể gửi bằng system call kill(). mặc định sẽ kthúc tiến trình đc chỉ định, tuy nhiên process có thể catch tín hiệu này và dọn dẹp trước khi kết thúc
	- SIGINT: tín hiệu này đc gửi tới các process trong nhóm foreground process. mặc định kết thúc tiến trình hiện tại
	- SIGCHLD: bất cứ khi nào 1 tiến trình dừng lại, nó sẽ gửi SIGCHLD tới process cha của nó. Mặc định SIGCHLD bị ignored.
	- SIGSTOP: chỉ có thể gửi bằng system call kill(). process ko thể caught or ignored. Mặc định sẽ tạm dừng process đc chỉ định
	- SIGSR1/SIGSR2: Signal có sẵn cho ngừoi dùng tự định nghĩa.
	
1.4 Sending signal

	- Signal có thể đc gửi qua hàm system call kill() trong mã nguồn.
	- ngoài ra cso thể gửi thông qua command kill trên terminal
	- có thể tự gửi signal đến bản thân tiến trình đó thông qua việc sử dụng hàm getpid().
	
	int kill (pid_t pid, int signo);// gửi signal tới 1 process có pid cụ thể
	- các đối số:
		+ pid: pid của 1 process
		+ signo: signal number
		+ trả về 0 nếu thành công, trả về < 0 nếu thất bại.
	
1.5 blocking và unblocking signal

	- khái niệm: 
	  + signal làm giám đoạn quá trình thực thi của process. Điều này trong nhiều trường hợp ko đc mong muốn xảy ra khi process đang thực thi một số đoạn mã quan trọng. Blocking signal dẽ giúp giải quyết vấn đề này.
	  + mỗi 1 process có thể chỉ định signal cụ thể nào đó mà nó muốn block. Nếu Signal bị block vẫn xảy ra thì nó sẽ đc kernel giữ vào hàng chờ xử lý(pending).
	  + tín hiệu chỉ đc gửi tới process sau khi nó đc unblocking
	  + DS các Signal bị block đc gọi là signal mask
	  
1.5.1 SIGNAL SETS

	* int sigemptyset(sigset_t* set);// tất cả các cờ trong signal table về 0
	* int sigfillset(sigset_t* set);// tất cả các cờ trong signal table lên 1
	* int sigaddset(sigset_t* set, int signo); signo nào đc nhắc đến lên 1
	* int sigdelset(sigset_t* set, int signo); signo nào đc nhắc đến về 0
	* int sigismember(const sigset_t* set, int signo); nếu return trả về 1 thì signo đang đc set trong mask, 0 thì signo ko đc set trong mask, -1 là lỗi	
	
	
SIGNAL MASK CỦA PROCESS: thuộc tích vốn có của process khi đc tạo ra 
 
SIGNAL MASK TẠM THỜI: thuộc tính muốn thay đổi, dùng để gán vào signal mask của process.

1.5.2 Blocking signals.

	- int sigpromask( int how, const sigset_t* newset, sigset_t* oldset );
	  + how
	  	. SIG_SETMASK: signal mask của process sẽ bị thay đổi thành newset.
	  	. SIG_SETMASK: newset sẽ đc thêm vào signal mask (phép OR)
	  	. SIG_UNBLOCK: newset sẽ bị xóa khỏi signal mask
	  + nếu oldset khác NULL, sigpromask sẽ lấy ra đc signal mask hiện tại và lưu vào oldset.
	  + nếu newset là NULL, sigpromask sẽ bỏ qua việc thay đổi giá trị của signal mask, nhưng nó sẽ lấy ra đc signal mask hiện tại và lưu vào oldset. nói cách khác, truyền NULL vào set như 1 cách lấy ra signal mask hiện tại.
	  
	- để lấy ra signal mask của process ta truyền newset == NULL.	sigpromask(int how, NULL , sigset_t* oldset );
	- để kiểm tra 1 signal có bị block hay unblock. sigismember(oldset, int signo);
	

	
>>>>>>>>>>>>>>cách sử dụng và ý nghĩa biến: volatile<<<<<<<<<<<<<<<<
	
Ý nghĩa của volatile
Khi khai báo một biến là volatile, trình biên dịch hiểu rằng:

Giá trị của biến có thể thay đổi bất cứ lúc nào, có thể do tác động từ bên ngoài chương trình.
Mọi lần truy cập vào biến volatile, chương trình sẽ đọc trực tiếp từ bộ nhớ thay vì sử dụng giá trị đã lưu trong các thanh ghi CPU hoặc tối ưu hóa nó.

Điều này đặc biệt hữu ích trong các trường hợp như:

Lập trình hệ thống nhúng: Biến volatile có thể được sử dụng để lưu trữ giá trị đọc từ các thanh ghi phần cứng, bộ đếm hoặc trạng thái của các thiết bị ngoại vi, và giá trị của các thanh ghi này có thể thay đổi mà không được kiểm soát bởi chương trình.
Đa luồng: Biến volatile dùng để lưu trữ giá trị mà các luồng khác nhau cùng sử dụng hoặc thay đổi, giúp đảm bảo rằng mọi luồng luôn nhìn thấy giá trị mới nhất của biến đó.
Bộ nhớ dùng chung với các tín hiệu: Trong ngữ cảnh xử lý tín hiệu hoặc các tín hiệu ngắt (interrupt), biến volatile đảm bảo rằng trình biên dịch sẽ không loại bỏ các câu lệnh hoặc dữ liệu có thể được thay đổi ngoài dự đoán.
	
	
====================================================================================================================================
BUổi 7: Socket
1.giới thiệu
2.flow hoạt động
3. Sockets: Internet Domain Socket
4. Sockets: Unix Domain


1. Định nghĩa
- socket là cơ chế truyền thông cho phép các tiến trình có thể giao tiếp với nhau dù các tiến trình có ở trên cũng 1 thiết bị hay khác thiết bị.
- socket đc đại diện bởi 1 file socket descriptor
- thông tin đc mô tả trong 1 file socket bao gồm: domain, type, protocol.

1.1 Domain (tên miền)

- tiến trình cần giao tiếp nằm trên cùng thiết bị hay khác thiết bị. Socket có 2 domain chính là: Internet Domain và UNIX Domain.
	- Domain--> Unix Domain		(protocol AF_UNIX)
		--> Internet Domain --> IP v4 (tập trung)	(protocol AF_INET)
				    --> IP v6			(protocol AF_INET6)
	 	
1.2 Type (cách thức truyền dữ liệu)
- mô tả cơ chế truyền nhận thông tin 
- socket có 2 type phổ biến là: + Stream socket (TCP)
				+ Datagram socket (UDP)
				
		Stream Socket(message, file)			Datagram Socket(audio, video)
	Tin cậy( đảm bảo dữ liệu nhận được		Không tin cậy( Dữ liệu nhận được có thể
	theo thứ tự, có thông báo nếu lỗi 		ko theo thứ tự, dữ liệu có thể mất trong
	xảy ra)					quá trình truyền mà ko có thông báo)
							
	Yêu cầu tạo kết nối trước khi trao đổi	Ko cần tạo kết nối trc khi trao đổi dữ liệu.
							Dữ liệu có thể đc gửi đi ngay cả khi tiến
							trình đích ko tồn tại.
							
	Thường được dùng khi dữ liệu cần truyền	thường dùng nếu dữ liệu cần truyền là các gói tin
	là chuỗi bit 	
	
1.3 Protocol(kiểu đóng gói dữ liệu)
- cách thức đóng gói dữ liệu
- Từ domain và type sẽ có 1 ds các protocol tương ứng để ta lựa chọn.
- thông thường với 1 Domain và Type đã chọn chỉ có 1 giao thức có thể dùng nên protocol thường có gtrị 0.
	+ Domain--> Unix Domain		(protocol AF_UNIX)
		--> Internet Domain --> IP v4 	(protocol AF_INET)
				    --> IP v6	(protocol AF_INET6)
	+ Type
	
2. Flow hoạt động
2.1 Flow hoạt động của Stream Socket
	- stream socket yêu cầu tạo 1 kết nối trước khi truyền dữ liệu.
	- tiến trình khởi tạo kết nối đóng vai trò là Client, tiến trình nhận được yêu cầu kết nối là Server
	
	
	
	
	
	
	
	
====================================================================================================================================	
	
	
Buổi 8 pipe va fifo

1. giới thiệu.

1.1 định nghĩa
	- Pipes là 1 trong số các phương thức IPC được sử dụng trong việc truyền thông liên tiến trình.
	- Pipes	chỉ giao tiếp 1 chiều, tức là chúng ta chỉ có thể sử dụng pipe sao cho 1 quá trình thực hiện ghi vào pipe quá trình kia đọc từ pipe
	- Truyền vào mảng fd[] gồm 2 phần tử, fd[1]: đầu write, fd[0]: đầu read
	
1.2 Hoạt động
	- Khi tạo 1 pipe, nó sẽ nằm trong RAM và được coi là 1 "virtual file"
	- Pipes có thể sử dụng trong quá trình tạo process
	- Khi 1 process ghi vào "virtual file" (hoặc có thể hiểu là pipe) thì 1 tiến trình liên quan(related-process) khác có thể đọc dữ liệu từ nó.
	- Tốc độ đọc ghi trên Ram rất là nhanh
	
	* Reading from a pipe:
		- Nếu cố gắng đọc dữ liệu từ 1 pipe "rỗng", thì đầu read sẽ block cho đến khi đọc được ít nhất 1 bytes.
		- Nếu đầu write của 1 đg ống bị đóng, đầu read đọc lại toàn bộ dữ liệu còn lại trong pipe và return 0.
	
	* Pipes have a limited capacity:
		- 1 pipe chỉ đơn giản là 1 bộ đệm đc duy trì trong bộ nhớ
		- Bộ đệm này có dung lượng tối đa. Khi 1 pipe đã đầy, chỉ khi khi đầu read lấy 1 số dữ liệu khỏi pipe thì đầu write mới có thể ghi tiếp dữ liệu vào pipe.
		
2. Tạo và sd PIPES

2.1 Tạo pipes
		int pipe(int fd[2])
	- Tạo 1 pipe mới. Trả về 2 file descriptor (fd) nằm trong fds.
	- Các đối số:
		+ fds[0] 	file descriptor chiều read của pipe
		+ fds[1] 	file descriptor chiều write của pipe
		+ trả về 0 nếu thành công, -1 nếu thất bại.
	- pipe()
	- Nếu ta tạo pipe trc khi gọi fork(). thì parent and child (related-process) có thể giao tiếp thông qua pipe. 
	
2.2 Giao tiếp 2 chiều
	- chỉ cần tạo 2 pipe để gửi dữ liệu theo từng hướng giữa 2 tiến trình
	- cần cảnh giác với các trường hợp bế tắc có thể xảy ra nếu cả 2 quy trình bị block trong khi 
		+ cố gắng đọc từ các pipe rỗng 
		+ cố gắng ghi vào các pipe đã đầy
	
	- Parent đóng cái trò writer
	- Child đóng vai trò reader
	
3. FIFOs - named Pipes
3.1 Định nghĩa

	- Đây là 1 khái niệm mở rộng của pipé. Pipé truyền thống thì ko đc đặt tên và chỉ tồn tại trong suốt vòng đời của process.
	- Sự khác biệt chính là FIFÓ có tên trong hệ thống tệp đc mở giống như 1 tệp thông thường.
	- Named Pipes có thể tồn tại miễn là hệ thống còn hoạt động. Vượt ra ngoài vòng đời của process. Có thể xóa đi nếu không còn sd.
	- 1 file FIFO là 1 file đặc biệt đc lưu trong bộ nhớ cục bộ, đc tạo ra bỏi hàm mkfifo() trong C.
	
3.2 Tạo FIFOs từ trình shell 

- lệnh mkfifo [ -m mode ] pathname
	vd: mkfifo -m 0666 ./helloFIFO
	
	
3.3 tạo fifo từ source code
	
	#define FIFO_FILE "./myfifo"
	mkfifo(FIFO_FILE, 0666);
	
4. XÂY DỰNG MÔ HÌNH CLIENT - SERVER WITH FIFOs
 	Bài toán: Xây dựng 1 mô hình client server sử dụng FIFÓ
 	
 	B1: Thiết lập kết nối
 		+ làm sao để client biết tới server?
 		+ well-know address/name
 			vị trí cố định
 		+ Server được định danh.
 			. cung cấp nhiều services
 			. client phải request tới để đk
 			. thêm chi phí (tiền, lập trình)
	
	
	 B2: Xử lý yêu cầu kết nối.
	 	-Server:
	 		+ tạo 1 fifo xử lý request.
	 		+ xử lý bản tin request
	 			. check key
	 			. check service.
	 			. Giới hạn số lượng kết nối.
	 		+ gửi ack chấp nhận/ không chấp nhận request
	 		
	 	-Client:
	 		+ tạo fifo gửi, nhận bản tin
	 			. Tên = TEMPLATE+PID
	 		+ đóng bản tin request
	 			. tên
	 			. yêu cầu service nào
	 			. key
	 		+ gửi request tới server
	 			. Server chấp nhận -> gửi nhận dữ liệu	
	 			. Server ko chấp nhận -> hủy bỏ FIFO 
	B3: Xử lý bản tin.
		- Nhớ lại rằng dữ liệu trong đường ống và FIFO là 1 luồng byte, ranh giới giữa nhiều bản tin không được bảo toàn.
		- Điều này có nghĩa là khi nhiều bản tin gửi đến 1 quá trình, chẳng hạn như Server thì người gửi và người nhận phải đồng ý về 1 số quy ước để tách các thư.
			+ kết thúc mỗi thư bằng ký tự phân cách.
				-> Ký tự ko bao giờ xuất hiện như 1 phần bản tin.
				-> quá trình đọc thông báo phải quét dữ liệu từ FIFO từng byte 1 cho đến khi tìm thấy ký tự phân tách.
			+ Bao gồm header có kích thước ổn định với trường độ dài trong mỗi bản tin.
				-> hiệu quả đối với các bản tin có kích thước tùy ý.
				-> dẫn đến sự cố nếu bản tin không đúng định dạng.
			+ Sử dụng các bản tin có độ dài cố định và yêu cầu Server luôn đọc bản tin có kích thước cố định này.
				-> điều này có lợi thế là đơn giản để lập trình
				-> dung lượng kênh truyền bị lãng phí.
				-> nếu 1 tin nhắn ko có độ dài phù hợp, thì tất cả các tin nhắn tiếp theo sẽ bị lệch. Trong trường hợp này, Server không thể khôi phục dễ dàng.
				
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	






















